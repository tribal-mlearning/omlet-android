/*
 * Copyright (c) 2012, TATRC and Tribal
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 * * Neither the name of TATRC or TRIBAL nor the
 *   names of its contributors may be used to endorse or promote products
 *   derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL TATRC OR TRIBAL BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.tribal.mobile.model;

import java.io.Serializable;
import java.util.List;

import org.simpleframework.xml.Attribute;
import org.simpleframework.xml.Element;
import org.simpleframework.xml.ElementList;

/**
 * Class that represents a <code>menu-item</code> in a content package.
 * 
 * @author Jon Brasted
 */
@Element(name = "menu-item")
public class MenuItem implements Serializable {
	/**
	 * Autogenerated serial version UID
	 */
	private static final long serialVersionUID = 9078276939955541579L;

	/** Fields */
	
	@Attribute(required = false)
	private String id;
	
	@Attribute
	private MenuItemType type;
	
	@Attribute(name = "layout", required = false)
	private LayoutType layoutType;
	
	@Attribute(required = false)
	private String title;
	
	@Attribute(name = "icon", required = false)
	private String iconPath;
	
	@Attribute(required = false)
	private String link;
	
	@Attribute(name = "enabled", required = false)
	private boolean isEnabled = true;
	
	@Attribute(name = "header-background", required = false)
	private String headerBackground;
	
	@ElementList(entry = "menu-item", inline = true, type = MenuItem.class, required = false)
	private List<MenuItem> children;
	
	private BaseContentItem linkedContentItem;
	
	private MenuItem parentMenuItem;
	
	private String packageId;
	
	/* Properties */
	
	public String getId() {
		if (id == null) {
			// if id is null, get the linked item's id
			if (linkedContentItem != null) {
				return linkedContentItem.getId();
			}
		}
		
		return id;
	}
	
	public MenuItemType getType() {
		return type;
	}
	
	public LayoutType getLayoutType() {
		return layoutType;
	}
	
	/**
	 * Returns the title.
	 * 
	 * @param getLinkedContentItemTitle	whether to use the <code>title</code> from the linked {@link BaseContentItem} instance, if there is one.
	 * @return							the title
	 */
	public String getTitle(boolean getLinkedContentItemTitle) {
		if (getLinkedContentItemTitle && linkedContentItem != null) {
			return linkedContentItem.getTitle();
		}
		
		return title;
	}
	
	/**
	 * Returns the title. Will call {@link #getTitle(boolean) getTitle} with a true flag, so the title is retrieved from the linked {@link BaseContentItem} instance, if there is one.
	 * 
	 * @return	the title			
	 */
	public String getTitle() {
		return getTitle(true);
	}
	
	/**
	 * Returns the icon path. Will retrieve the icon path from the linked {@link BaseContentItem} instance, if there is one.
	 * 
	 * @return	the icon path
	 */
	public String getIconPath() {
		if (linkedContentItem != null) {
			return linkedContentItem.getIconPath();
		}
		
		return iconPath;
	}
	
	/**
	 * Sets the icon path on the {@link MenuItem} object, not the linked {@link BaseContentItem} instance, if there is one.
	 * @param value
	 */
	public void setIconPath(String value) {
		this.iconPath = value;
	}
	
	public String getLink() {
		return link;
	}
	
	/**
	 * Returns a boolean value representing whether the item is enabled. If there is a linked {@link BaseContentItem} instance, a logical AND is performed on that value of
	 * <code>isEnabled</code> with the <code>isEnabled</code> value from {@link MenuItem}. 
	 * 
	 * @return	a boolean value representing whether the item is enabled
	 */
	public boolean isEnabled() {
		// if there is a linked content item, do a logical AND on the results
		if (linkedContentItem != null) {
			return (isEnabled & linkedContentItem.isEnabled());
		} else {		
			return isEnabled;
		}
	}
	
	public String getHeaderBackground() {
		return headerBackground;
	}
	
	public List<MenuItem> getChildren() {
		return children;
	}
	
	public boolean hasChildren() {
		return (children != null && !children.isEmpty());
	}
	
	@SuppressWarnings("unchecked")
	public <T> T getLinkedContentItem(Class<? extends BaseContentItem> className) {
		return (T)linkedContentItem;
	}
	
	public BaseContentItem getLinkedContentItem() {
		return linkedContentItem;
	}
	
	public void setLinkedContentItem(BaseContentItem value) {
		this.linkedContentItem = value;
	}
	
	public boolean hasLinkedContentItem() {
		return (linkedContentItem != null);
	}
	
	public MenuItem getParentMenuItem() {
		return parentMenuItem;
	}
	
	public void setParentMenuItem(MenuItem value) {
		parentMenuItem = value;
	}
	
	/**
	 * Returns the title of the parent {@link MenuItem} object, if there is one. Otherwise returns an empty string.
	 * 
	 * @return
	 */
	public String getParentMenuItemTitle() {
		if (parentMenuItem != null) {
			return parentMenuItem.getTitle(false);
		}
		
		return "";
	}
	
	public String getPackageId() {
		return packageId;
	}
	
	public void setPackageId(String value) {
		this.packageId = value;
	}

	/*
	 * Methods
	 */
	
	/**
	 * Returns the full path to the {@link MenuItem} from the package root, separated by a dot, prefixed with the package ID. 
	 * 
	 * @return	the full path to the {@link MenuItem} from the package root, separated by a dot, prefixed with the package ID
	 */
	public String getFullIdPathWithPackageId() {
		// get full id path
		String fullIdPath = getFullIdPath();
		
		// append package id
		String fullIdPathWithPackage = getPackageId() +  "." + fullIdPath;
		
		return fullIdPathWithPackage;
	}
	
	/**
	 * Returns the full path to the {@link MenuItem} from the package root, separated by a dot.
	 * @return	the full path to the {@link MenuItem} from the package root, separated by a dot
	 */
	public String getFullIdPath() {
		if (parentMenuItem != null) {
			return parentMenuItem.getFullIdPath() + "." + getId();
		} else {
			return getId();
		}
	}
	
	/*
	 * Static Helper Methods
	 */
	
	/**
	 * Recursively search for a {@link MenuItem} object based on a title. 
	 * 
	 * @param children	the {@link MenuItem} children {@link List}
	 * @param title		the title to search for
	 * @return			a {@link MenuItem} instance or <code>null</code> if a {@link MenuItem} instance is not found
	 */
	public static MenuItem getMenuItemByTitle(List<MenuItem> children, String title) {
		MenuItem menuItem = null;
		
		for (int index = 0; index < children.size(); index++) {
			menuItem = children.get(index); 
			
			if (menuItem.getTitle().equalsIgnoreCase(title)) {
				return menuItem;
			} else {
				List<MenuItem> innerChildren = menuItem.getChildren();
				menuItem = null;
				
				if (innerChildren != null && innerChildren.size() > 0) {
					menuItem = getMenuItemByTitle(innerChildren, title);
				}
				
				if (menuItem != null) {
					return menuItem;
				}
			}
		}
		
		return null;
	}
	
	/**
	 * Invokes {@link #findHeaderBackground(MenuItem) findHeaderBackground}, passing in the parameter <code>this</code>.
	 * 
	 * @return	the header background image path or <code>null</code> if the header background is not found
	 */
	public String findHeaderBackground() {
		return findHeaderBackground(this);
	}
	
	/**
	 * Find and return the header background image path for a given {@link MenuItem}. If one is not found, a recursive search through the {@link MenuItem} parent is performed.
	 * 
	 * @param menuItem	the menu item to start looking inside
	 * @return			the header background image path or <code>null</code> if the header background is not found
	 */
	private String findHeaderBackground(MenuItem menuItem) {
		if (menuItem.getHeaderBackground() != null) {
			return menuItem.getHeaderBackground();
		} else {
			if (menuItem.getParentMenuItem() != null) {
				return findHeaderBackground(menuItem.getParentMenuItem());
			}
		}
		
		return null;
	}
}