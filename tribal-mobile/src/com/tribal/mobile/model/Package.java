/*
 * Copyright (c) 2012, TATRC and Tribal
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 * * Neither the name of TATRC or TRIBAL nor the
 *   names of its contributors may be used to endorse or promote products
 *   derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL TATRC OR TRIBAL BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.tribal.mobile.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.lang3.StringUtils;
import org.simpleframework.xml.Attribute;
import org.simpleframework.xml.ElementList;
import org.simpleframework.xml.ElementListUnion;
import org.simpleframework.xml.Root;

import android.text.TextUtils;

/**
 * Class that represents a content package.
 * 
 * @author Jon Brasted
 */
@Root(name = "package")
public class Package implements Serializable {
	/**
	 * Autogenerated serial version UID
	 */
	private static final long serialVersionUID = -5473349116349778068L;

	/* Fields */

	@Attribute
	private String id;

	@Attribute(name = "entry-point", required = false)
	private String entryPoint;

	private String externalRootPath;

	@ElementListUnion({
			@ElementList(entry = "html", inline = true, type = HtmlItem.class, required = false),
			@ElementList(entry = "book", inline = true, type = BookItem.class, required = false),
			@ElementList(entry = "video", inline = true, type = VideoItem.class, required = false),
			@ElementList(entry = "menu-item", inline = true, type = MenuItem.class, required = false) })
	private ArrayList<Serializable> children;

	private ArrayList<HtmlItem> htmlItems;
	private ArrayList<BookItem> bookItems;
	private ArrayList<VideoItem> videoItems;
	private ArrayList<MenuItem> menuItems;
	private ArrayList<BaseContentItem> contentItems;

	/* Properties */

	public String getId() {
		return id;
	}

	public String getEntryPoint() {
		return entryPoint;
	}

	public String getExternalRootPath() {
		return externalRootPath;
	}

	public void setExternalRootPath(String value) {
		this.externalRootPath = value;
	}

	@SuppressWarnings("unchecked")
	public List<BaseContentItem> getContentItems() {
		// return a (shallow) cloned collection of content items
		ArrayList<BaseContentItem> clonedContentItems = (ArrayList<BaseContentItem>) contentItems.clone();

		return clonedContentItems;
	}

	/* Constructor */
	public Package() {
		children = new ArrayList<Serializable>();

		htmlItems = new ArrayList<HtmlItem>();
		bookItems = new ArrayList<BookItem>();
		videoItems = new ArrayList<VideoItem>();
		menuItems = new ArrayList<MenuItem>();
		contentItems = new ArrayList<BaseContentItem>();
	}

	/* Methods */

	/**
	 * Processes package and sets mime types, links children to parents, updated icon paths and paths.
	 * It it is mandatory for the method to be executed for the mobile framework to perform correctly.
	 */
	public void processItems() {
		htmlItems.clear();
		bookItems.clear();
		menuItems.clear();

		for (Serializable item : children) {
			if (item.getClass().equals(HtmlItem.class)) {
				htmlItems.add((HtmlItem) item);
			} else if (item.getClass().equals(BookItem.class)) {
				bookItems.add((BookItem) item);
			} else if (item.getClass().equals(VideoItem.class)) {
				videoItems.add((VideoItem) item);
			} else if (item.getClass().equals(MenuItem.class)) {
				menuItems.add((MenuItem) item);
			}
		}

		// add the items to the list
		contentItems.clear();
		contentItems.addAll(htmlItems);
		contentItems.addAll(bookItems);
		contentItems.addAll(videoItems);

		// set content mime type
		setContentMimeType();

		// link menu items to content items
		linkMenuItemsToContent(menuItems);

		// set parent menu items
		setParentMenuItems(menuItems);

		// set package id
		setPackageIdOnItems();

		// update icon paths
		updateIconPaths();

		// update paths
		updatePaths();
	}

	private void setContentMimeType() {
		for (BaseContentItem contentItem : contentItems) {
			contentItem.setMimeType();
		}
	}

	private void linkMenuItemsToContent(List<MenuItem> menuItems) {
		BaseContentItem baseContentItem = null;
		String[] splitLink;
		MenuItem menuItem;

		for (int index = 0, menuItemsSize = menuItems.size(); index < menuItemsSize; index++) {
			menuItem = menuItems.get(index);

			if (menuItem.getType() != MenuItemType.menu) {

				try {
					// TODO: Implement cross package linking
					splitLink = menuItem.getLink().split("[.]");

					if (splitLink.length > 0) {
						if (splitLink.length == 2) {
							baseContentItem = findContentItemById(splitLink[1]);
						} else {
							baseContentItem = findContentItemById(splitLink[0]);
						}
					} else {
						baseContentItem = findContentItemById(menuItem.getLink());
					}
				} catch (Exception e) {
					e.printStackTrace();
				}

				if (baseContentItem != null) {
					// set child on parent
					menuItem.setLinkedContentItem(baseContentItem);

					// set parent on child
					baseContentItem.setMenuItemParent(menuItem);
				} else {
					// need to remove the menu item otherwise there will be an
					// error when the menus are generated
					menuItems.remove(index);

					index--;
					menuItemsSize--;
				}
			}

			if (menuItem.hasChildren()) {
				linkMenuItemsToContent(menuItem.getChildren());
			}
		}
	}

	private void setParentMenuItems(List<MenuItem> menuItems) {
		for (MenuItem menuItem : menuItems) {
			if (menuItem.hasChildren()) {
				setParentMenuItems(menuItem);
			}
		}
	}

	private void setParentMenuItems(MenuItem menuItem) {
		for (MenuItem childMenuItem : menuItem.getChildren()) {
			// set parent
			childMenuItem.setParentMenuItem(menuItem);

			if (childMenuItem.hasChildren()) {
				setParentMenuItems(childMenuItem);
			}
		}
	}

	private void setPackageIdOnItems() {
		String packageId = getId();

		updatePackageIdOnMenuItems(menuItems);

		for (BaseContentItem contentItem : contentItems) {
			contentItem.setPackageId(packageId);
		}
	}

	private void updateIconPaths() {
		// iterate over all the items and set their icon paths

		String iconPath = null;
		String externalRootPath = this.getExternalRootPath();

		for (MenuItem menuItem : menuItems) {
			updateMenuItemPathsRecursively(menuItem, externalRootPath);
		}
	
		for (BaseContentItem contentItem : contentItems) {
			iconPath = contentItem.getIconPath();

			if (!TextUtils.isEmpty(iconPath)) {
				contentItem.setIconPath(externalRootPath + "/" + iconPath);
			}
		}
	}
	
	private void updateMenuItemPathsRecursively(MenuItem menuItem, String externalRootPath) {
		String iconPath = menuItem.getIconPath();
		
		if (iconPath != null) {
			menuItem.setIconPath(externalRootPath + "/" + iconPath);
		}
		
		if (menuItem.hasChildren()) {			
			for (MenuItem childMenuItem : menuItem.getChildren()) {
				updateMenuItemPathsRecursively(childMenuItem, externalRootPath);
			}
		}
	}

	private void updatePaths() {
		// iterate over all the content items and set their paths

		String path = null;
		String externalFilePrefix = "file://%s";
		String externalRootPath = String.format(externalFilePrefix, this.getExternalRootPath());

		for (BaseContentItem contentItem : htmlItems) {
			path = contentItem.getPath();

			if (!TextUtils.isEmpty(path)) {
				contentItem.setPath(externalRootPath + "/" + path);
			}
		}
	}

	private void updatePackageIdOnMenuItems(List<MenuItem> menuItemChildren) {
		String packageId = getId();

		for (MenuItem menuItem : menuItemChildren) {
			menuItem.setPackageId(packageId);

			if (menuItem.hasChildren()) {
				updatePackageIdOnMenuItems(menuItem.getChildren());
			}
		}
	}

	public MenuItem findMenuItemByPath(String path) {
		// check whether the path starts with the id of the package
		String idPrefix = getId() + ".";

		if (path.startsWith(idPrefix)) {
			path = path.replace(idPrefix, "");
		}

		return findMenuItemByPath(path, menuItems);
	}

	private MenuItem findMenuItemByPath(String path, List<MenuItem> menuItems) {
		// path = root.missiontools.checklists.missionpreparation

		// find the first dot
		if (StringUtils.countMatches(path, ".") == 0) {
			return findMenuItemById(path, menuItems, true, true);
		} else {
			// find by path

			MenuItem menuItem = null;

			// split the string by the first period
			String[] pathSplits = path.split("[.]", 2);

			if (pathSplits.length == 2) {
				// try and get the item
				menuItem = findMenuItemById(pathSplits[0], menuItems, false, true);

				if (menuItem != null && menuItem.hasChildren()) {
					menuItem = findMenuItemByPath(pathSplits[1], menuItem.getChildren());
				}
			}

			return menuItem;
		}
	}

	private MenuItem findMenuItemById(String id, List<MenuItem> children, boolean recursive, boolean includeContentItems) {
		MenuItem menuItem = null;
		String itemId = null;

		for (MenuItem item : children) {
			itemId = item.getId();

			if (itemId != null && itemId.equalsIgnoreCase(id)) {
				return item;
			} else {
				if (includeContentItems) {
					BaseContentItem baseContentItem = item.getLinkedContentItem(BaseContentItem.class);

					if (baseContentItem != null && baseContentItem.getId().equalsIgnoreCase(id)) {
						return item;
					}
				}

				if (recursive && item.hasChildren()) {
					menuItem = findMenuItemById(id, item.getChildren(), recursive, includeContentItems);

					if (menuItem != null) {
						return menuItem;
					}
				}
			}
		}

		return null;
	}

	/**
	 * Return first {@link MenuItem} instance found, if there is one. This is used as a fallback if there is no <code>entry-point</code> specified in the package.
	 * 
	 * @return
	 */
	public MenuItem findFirstMenuItem() {

		MenuItem menuItem = null;
		if (menuItems.size() > 0) {
			menuItem = menuItems.get(0);
		}

		return menuItem;
	}

	/**
	 * Find and return the {@link BaseContentItem} instance for a given id.
	 * 
	 * @param id	the id of the item being searched for
	 * @return		the {@link BaseContentItem} instance, if there is one found
	 */
	public BaseContentItem findContentItemById(String id) {
		// strip the package prefix
		if (id.startsWith(getId() + ".")) {
			String packagePrefix = getId() + ".";

			id = id.substring(packagePrefix.length());
		}

		BaseContentItem item = null;

		item = findContentItemById(id, htmlItems);
		
		if (item == null) {
			item = findContentItemById(id, bookItems);
			
			if (item == null) {
				item = findContentItemById(id, videoItems);
			}
		}

		return item;
	}

	private BaseContentItem findContentItemById(String id, ArrayList<? extends BaseContentItem> collection) {
		for (BaseContentItem baseContentItem : collection) {
			if (baseContentItem.getId().equalsIgnoreCase(id)) {
				return baseContentItem;
			}
		}

		return null;
	}

	/**
	 * Find and return the {@link BaseContentItem} instance for a given id and class type.
	 * 
	 * @param id			the id of the item being searched for
	 * @param classType		the type of class being searched for. Valid values are: {@link HtmlItem}. {@link BookItem} and {@link VideoItem}.  
	 * @return				the instance of the class, if there is one
	 * @throws Exception	an exception with a message denoting that a content item could not be found with the given ID and class type.
	 */
	@SuppressWarnings("unchecked")
	public <T> T findContentItemById(String id,
			Class<? extends BaseContentItem> classType) throws Exception {
		ArrayList<? extends BaseContentItem> collection = null;

		if (classType.equals(HtmlItem.class)) {
			collection = htmlItems;
		} else if (classType.equals(BookItem.class)) {
			collection = bookItems;
		} else if (classType.equals(VideoItem.class)) {
			collection = videoItems;
		} else {
			throw new Exception("class type " + classType + " is not currently supported by Package.findContentItemById(...)");
		}

		for (BaseContentItem baseContentItem : collection) {
			if (baseContentItem.getId().equalsIgnoreCase(id)) {
				return (T) baseContentItem;
			}
		}

		throw new Exception("Could not find content item with ID '" + id
				+ "' and type '" + classType + "'.");
	}
}